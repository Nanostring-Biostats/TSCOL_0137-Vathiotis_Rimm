##########################################
# Collaboration: TSCOL_0137
#   Senior PI: David Rimm
#   Lead Investigator: Ioannis Vathiotis
#
# Zhi Yang

# Inputs needed: graphing_adjusted_log2_expression_data_WITH DSP.xlsx
# TargetsNotInProtein.csv
# TSCOL_0137_Initialized.Rdata generated by TSCOL_0137 Initialize and Univariate.R
##########################################

##########################################
# Libraries
##########################################
library(readxl)
library(ggplot2)
library(ggrepel)
library(survival)
library(glmnet)
library(DT)
library(pROC)
library(survminer)
library(patchwork)
library(glmnetUtils)
library(OptimalCutpoints)
library(rsq)
library(caret)
library(kernelboot)

##########################################
##### Custom Functions ####

# prune_collinearity: remove collinearity and reduce the maximum collinearity to be less than cutoff, 0.7. 
prune_collinearity <- function(data, cutoff = 0.7, out_Surv){
  dataSig <- data
  dataSig[is.na(dataSig)] <- 0 
  
  # create the correlation matrix
  cormat <- cor(t(dataSig))
  diag(cormat) <- 0
  dataNew <- dataSig[-which(apply(cormat,1,function(x) any(abs(x) > cutoff))==TRUE), ]
  dataCor <- dataSig[which(apply(cormat,1,function(x) any(abs(x) > cutoff))==TRUE), ]
  
  # rank the most predictive variables
  dataCorRsq <- out_Surv[which(out_Surv$target %in% rownames(dataCor)), ]
  dataCorRsq <- dataCorRsq[order(dataCorRsq$rsquared, decreasing = T), ]
  
  # start the pruning process by only keeping the predictor with highest rsquared
  varList <- as.character(dataCorRsq$target)
  addVarlist <- NULL
  rmVarlist <- NULL
  dataCorMat <- cor(t(dataCor))
  while(length(varList)>0){
    addVarlist <- c(addVarlist, varList[1])
    removeVars <- names(which((dataCorMat[which(rownames(dataCorMat)==varList[1]),]>cutoff)==TRUE))
    removeVars <- setdiff(removeVars, varList[1])
    varList <- setdiff(varList, c(varList[1], removeVars))
    rmVarlist <- c(rmVarlist, removeVars)
    dataCorMat <- cor(t(dataCor[which(rownames(dataCor) %in% varList),]))
  }
  
  dataAdd <- dataSig[which(rownames(dataSig) %in% 
                             c(addVarlist[2], rownames(dataNew))), ]
  tmp <- cor(t(dataAdd))
  diag(tmp) <- 0
  print(range(abs(tmp)))
  
  return(addVarlist)
}

# variable_of_importance: returning the predictors with non-zero coefficients on bootstrapped data
variable_of_importance <- function(devList, x, y, family = "binomial"){
  # extract the optimal alpha and lambda values 
  devList <- data.frame(devList)
  alphaOpt <- max(devList$alpha[devList$measure.min == max(devList$measure.min)])
  lambdaOpt <- devList$lambda.min[which(devList$alpha==alphaOpt)]
  
  # use bootstrapped samples to choose important variables 
  bootID <- sample(seq_len(length(y)), length(y), replace = T)
  nonbootID <- setdiff(seq_len(length(y)), bootID)
  
  fit <- glmnet(x[bootID, ], y[bootID], 
                alpha = alphaOpt, lambda = lambdaOpt, family = family)
  
  coefMat <- as.matrix(coef(fit))
  geneVar <- names(coefMat[which(coefMat!=0),])
  geneVar <- setdiff(geneVar, "(Intercept)")
  
  return(geneVar)
}

# scores_calculator: calculating the scores of given predictors
scores_calculator <- function(devList, x, y, family = "binomial"){
  # extract the optimal alpha and lambda values
  devList <- data.frame(devList)
  alphaOpt <- max(devList$alpha[devList$measure.min == max(devList$measure.min)])
  lambdaOpt <- devList$lambda.min[which(devList$alpha==alphaOpt)]
  
  # fit the model using the optimal values 
  fit <- glmnet(x, y,                 
                alpha = alphaOpt, lambda = lambdaOpt, family = family)
  
  testfit <- coef(fit)
  scores <- apply(x, 1, function(vec) {sum(vec[testfit@i[-1]] * testfit@x[-1])})
  tmp <- apply(x, 1, function(y) {y[testfit@i[-1]] * testfit@x[-1]})
  
  geneVar <- data.frame(gene = colnames(x)[testfit@i[-1]],
                        coefficient = testfit@x[-1], 
                        row.names = NULL)
  return(list(geneVar, scores, testfit))
}

# smooth_bootstrap: calculate confidence intervals for AUC via smoothed bootstrapping
smooth_bootstrap <- function(dataFinal, devList = devList){
  # extract the optimal alpha and lambda values
  devList <- data.frame(devList)
  alphaOpt <- max(devList$alpha[devList$measure.min == max(devList$measure.min)])
  lambdaOpt <- devList$lambda.min[which(devList$alpha==alphaOpt)]
  
  newX <- as.matrix(dataFinal[, -1])
  newY <- dataFinal$y
  fit <- glmnet(newX, newY, 
                alpha = alphaOpt, lambda = lambdaOpt, family = "binomial")
  testfit <- coef(fit)
  scores <- apply(newX, 1, function(vec) {sum(vec[testfit@i[-1]] * testfit@x[-1])})

  rocobj <- roc(as.numeric(newY==1), 
                scores, direction = "<")
  return(list(auc = rocobj$auc, 
              rocobj, 
              newY, 
              scores,
              coords(rocobj,"best", ret=c("ppv","npv", "sensitivity", "specificity"))))
}

# smooth_bootstrap_selected: calculate confidence intervals for AUC for a gene subset via smoothed bootstrapping
smooth_bootstrap_selected <- function(dataFinal, testfit, genesList){
  newX <- as.matrix(dataFinal[, -1])
  newY <- dataFinal$y
  scores <- apply(newX, 1, function(vec) {sum((vec * testfit[as.character(genesList),]))})
  
  rocobj <- roc(as.numeric(newY==1), 
                scores, direction = "<")
  
  return(list(auc = rocobj$auc, rocobj, 
              newY, scores,
              coords(rocobj,"best", ret=c("ppv","npv","sensitivity","specificity"))))
}

# ggboxroc: output boxplot of scores and ROC curves for a fitted model 
ggboxroc <- function(aucList = aucList, labels){
  aucList[[1]][[3]] <- factor(aucList[[1]][[3]], labels = labels)
  
  
  dat <- data.frame(scores = aucList[[1]][[4]], 
                    outcome = aucList[[1]][[3]])
  
  # draw the boxplot 
  ggplot(dat, aes(x = outcome, y = scores, color = outcome)) +
    geom_boxplot()+
    geom_jitter(width=0.1, size = 1) +
    scale_color_manual(values = c("red", "darkblue")) +
    labs(color = "") +
    xlab("") +
    ylab("Scores") +
    theme_bw(base_size = 8) +
    theme(panel.grid.minor = element_blank(),
          panel.grid.major = element_blank(),
          legend.position = "none",
          plot.tag = element_text(face = "bold"))  -> p1
  
  rocList <- aucList[[2]]
  aucCI <- quantile(unlist(rocList[,1]), c(0.025, 0.50, 0.975))
  
  # draw the ROC plot
  ggroc(rocList[,2], alpha = 0.1) +
    scale_color_manual(values = rep("grey", length = nrow(aucList[[2]]))) +
    geom_abline(
      slope = 1,
      intercept = 1,
      linetype = "dashed",
      alpha = 0.7,
      color = "grey"
    ) + 
    scale_x_continuous(trans = "reverse") +
    xlab("1-Specificity")+
    ylab("Sensitivity") +
    theme_bw(base_size = 8) +
    annotate("text", x = 0.30, y = 0.25, size = 3, 
             vjust = 0, label = paste0("AUC = ", sprintf("%.3f", aucCI[2]),
                                       "\n95% CI [", sprintf("%.3f", aucCI[1]), 
                                       ", ", sprintf("%.3f", aucCI[3]),"]")) +
    theme(panel.grid.minor = element_blank(),
          panel.grid.major = element_blank(),
          legend.position = "none",
          plot.tag = element_text(face = "bold")) +
    ggtitle("") -> p2
  
  return(list(p1, p2))
  
}

# varimpAUC: calculate the decrease in AUC for each predictors 
varimpAUC <- function(newx, y, coefmat, genes, nperm){
  
  scores <- apply(newx, 1, 
                  function(vec) {sum((vec[coefmat@i[-1]] * coefmat@x[-1])[genes])})
  auc <- roc(as.numeric(y==1), scores, direction = "<")$auc
  
  set.seed(2020)
  resmat <- matrix(NA, nrow = nperm, ncol = length(genes), 
                   dimnames = list(1:nperm, 
                                   genes))
  
  # start the permutation process by randomly changing the order of a given predictor 
  for(n in 1:nperm){
    sampleids <- sample(1:nrow(x))
    
    for (gene in genes){
      xtmp <- newx
      xtmp[, gene] <- xtmp[sampleids, gene]
      scores <- apply(xtmp, 1, 
                      function(vec) {sum((vec[coefmat@i[-1]] * coefmat@x[-1])[genes])})
      rocobj <- roc(as.numeric(y==1), scores, direction = "<")
      resmat[n, gene] <- rocobj$auc
    }
  }
  AUCchange <- auc - colMeans(resmat)
  AUCchange <- data.frame(coef = coefmat[genes, ], 
                          AUC = AUCchange, 
                          percent = AUCchange/auc)
  return(AUCchange)
}


######################
#### Data Loading ####
load("data/TSCOL_0137_Initialized.Rdata")
# remove control from the analysis
removeIndex <- unlist(sapply(c("_MouseIgG", "_RabbitIgG", 
                               "_Histone", "_S6", "POS", "NEG", "IgG"), 
                             function(pattern) grep(pattern, rownames(data))))
targetannot <- targetannot[-removeIndex, ]
data <- data[-removeIndex, ]

# create folders to store different output formats
if(file.exists("figs") == FALSE){
  dir.create("figs/")
  dir.create("figs/tiff")
  dir.create("figs/svg")
  dir.create("figs/jpg")
}

####################################################
#### Section 2: Creating correlation heatmaps    ###
#### 2.1: create a data.frame with Bulk RNA and DSP
x <- as.data.frame(t(data[targetannot$run %in% c('Bulk','Mean DSP'), ]))
x[is.na(x)] <- 0

# obtain the annotation
targetannot2 <- targetannot[targetannot$run %in% c('Bulk','Mean DSP'), ]

# get target names in DSP for matching target names in Bulk RNA
targets_DSP <- sapply(strsplit(targetannot2$Target[which(targetannot2$run=="Mean DSP")], "_"), function(x) x[[2]]) %>% unique()

proteins_to_be_matched <- targets_DSP[-which(targets_DSP %in% targetannot2$Gene[which(targetannot2$run!="Mean DSP")])]

#### 2.2: match RNA target names with DSP proteins 
matchedproteins <- read.csv(file.path("data", "TargetsNotInProtein.csv"),
                            stringsAsFactors = FALSE, header = FALSE)
stopifnot(proteins_to_be_matched==matchedproteins[,1])

# match target names in proteins with target names in Bulk RNA
new_target_DSP <- sapply(targets_DSP, function(x) {
  if(!(x %in% matchedproteins[,1])){
    return(x)
  } else {
    tmp <- matchedproteins[which(x == matchedproteins[,1]),2]
    if(tmp!=""){
      return(tmp)
    } 
  }
}) %>% unlist()

#### 2.3: calculate correlation between three compartments and sum in DSP and Bulk RNA
# calculate the row means for different compartment
x$S100comp <- rowMeans(x[, paste0("Mean_", targets_DSP, "_Melanocyte")])
x$CD45comp <- rowMeans(x[, paste0("Mean_", targets_DSP, "_CD45")])
x$CD68comp <- rowMeans(x[, paste0("Mean_", targets_DSP, "_CD68")])
x$Sum <- rowSums(x[, c("S100comp", "CD45comp", "CD68comp")])

cormat <- matrix(NA, nrow = length(new_target_DSP), ncol = 4,
                 dimnames = list(c(unname(new_target_DSP)), 
                                 c("Sum", "S100/HMB45", "CD45", "CD68")))

# calculate the spearman correlation between DSP and Bulk RNA
for(i in seq_len(nrow(cormat))){
  target <- unname(new_target_DSP)[i]
  cormat[i, 1] <- cor(x[, target], x$Sum, method = "spearman")
  cormat[i, 2] <- cor(x[, target], x$S100comp, method = "spearman")
  cormat[i, 3] <- cor(x[, target], x$CD45comp, method = "spearman")
  cormat[i, 4] <- cor(x[, target], x$CD68comp, method = "spearman")
}


#### 2.4: generate the correlation heatmaps and output it as a table
p <- pheatmap::pheatmap(cormat, cluster_cols = TRUE, 
                        main = "Spearman Ranked Correlation Coefficient",
                        ylab="test")

write.table(round(cormat, 4),
            file = "output/Rvalues-protein-RNA.csv",
            sep = " ", quote = FALSE)

#### 2.5: save the correlation heatmap as figure 2
ggsave(p, filename = file.path("figs", "tiff", "Figure2.tiff"), 
       dpi = 400, width = 4, height = 8, units = "in",
       type = "cairo")
ggsave(p, filename = file.path("figs", "svg", "Figure2.svg"), 
       dpi = 400, width = 4, height = 8, units = "in")
ggsave(p, filename = file.path("figs", "jpg", "Figure2.jpg"), 
       dpi = 400, width = 4, height = 8, units = "in",
       type = "cairo")

rm(list = c("p", "x", "targetannot2", "matchedproteins", "cormat",
            "new_target_DSP", "proteins_to_be_matched", "targets_DSP",
            "i", "target", "removeIndex"))

####################################################################
#### Section 3: Building regularized logistic regression models ####
#### 3.1: Removing highly correlated variables ####
# provide parameters for cross-validation in glmnet
measure  <- "auc" 
nfolds <- 4
alphaLength <- 21
nalpharep <- 40
seed <- 1
nrep <- 1000

# build three models based on different subsets specified in runNames 
runNames <- list(c('Bulk','Mean DSP'), c('Mean DSP'), c('Bulk'))
filename <- "Response"

for (i in seq_len(length(runNames))){
  runName <- runNames[[i]]
  # extract R-squared for logistic regression models
  out_Surv <- data.frame(target = rownames(data[targetannot$run %in% runName, ]))
  tmp <- unlist(apply(data[targetannot$run %in% runName, ], 1, function(x) {
    tmp <- annot
    tmp$Exp <- unlist(x)
    mod <- glm(Response.NS ~ Exp, data = tmp, family = binomial)
    c(coef(summary(mod))[2,4], rsq(mod))
  }))
  out_Surv[, c("pval", "rsquared")] <- tmp
  
  # Remove collinearity by keeping the variable with highest R-squared
  addVarlist <- prune_collinearity(
    data = data[(targetannot$run %in% runName), ][out_Surv$pval<0.10, ], 
    out_Surv = out_Surv, cutoff = 0.7)
  
  #### 4.2: subset complete data ####
  x <- as.data.frame(t(data[targetannot$run %in% runName, ]))
  x[is.na(x)] <- 0
  x <- as.matrix(x)
  
  # non-correlated x
  selectedx <- x[, which(colnames(x) %in% addVarlist)]
  standbylist <- setdiff(colnames(x), addVarlist)
  y <- as.numeric(annot$Response.NS == "R") 
  
  #### 3.3: fit models with cross-validation on DSP and bulk RNA combined #### 
  set.seed(seed)
  alphaList <- lapply(1:nalpharep, function(i){
    trainID <- caret::createDataPartition(y, p = 4/5, list = FALSE)
    train_y <- y[trainID]
    train_x <- selectedx[trainID, ]
    test_y <- y[setdiff(seq_len(length(y)), trainID)]
    test_x <- selectedx[setdiff(seq_len(length(y)), trainID), ]
    
    if(length(unique(test_y))==1){
      trainID <- caret::createDataPartition(y, p = 4/5, list = FALSE)
      train_y <- y[trainID]
      train_x <- selectedx[trainID, ]
      test_y <- y[setdiff(seq_len(length(y)), trainID)]
      test_x <- selectedx[setdiff(seq_len(length(y)), trainID), ]
    }
    
    foldid <- caret::createFolds(train_y, k = nfolds, list = FALSE)
    
    cvfit <- cva.glmnet(train_x, train_y, family = "binomial", nfolds = nfolds, 
                        foldid = foldid, type.measure = "auc", 
                        alpha = seq(0, 1, len = alphaLength))
    devList <- sapply(cvfit[[3]], function(fit){
      
      pred <- c(stats::predict(fit, newx=test_x, s="lambda.min"))
      
      auc <- pROC::auc(as.numeric(test_y == 1),
                       pred, direction = "<")
      
      c(auc, fit$lambda.min)
      
    })
    devList <- cbind(cvfit[[1]], t(devList))
    colnames(devList) <- c("alpha", "measure.min", "lambda.min")
    return(devList)
  })
  
  # store the results 
  devList <- Reduce("+",alphaList)/nalpharep
  
  #### 3.4: calculate variable of importance by fitting all variables to the model via bootstrapping #### 
  bsList <- lapply(1:1000, function(i) 
    variable_of_importance(devList = devList, x = x, y = y, family = "binomial"))
  # calculate the average size of models
  modelSize <- median(sapply(bsList, length))
  # select the top variables with the size of modelSize
  VarSelected <- names(sort(table(unlist(bsList)), decreasing = TRUE)[seq_len(modelSize)])
  
  
  #### 3.5: calculate the AUC confidence interval via smoothed bootstrapping 
  dataFinal <- data.frame(y = as.factor(y), x[,c(VarSelected)])
  set.seed(seed)
  aucList <- kernelboot(dataFinal, function(x) 
    smooth_bootstrap(x, devList = devList), R=nrep, kernel = "gaussian")
  
  # print out 95% confidence interval and median of measures including PPV, NPV, sensitivity and specificity
  apply(do.call(rbind, aucList[[2]][,5]), 2, 
        function(x) quantile(x, c(0.5, 0.025, 0.975))) %>% round(3)
  
  # draw the boxplot of scores and AUC curves 
  p <- ggboxroc(aucList = aucList, labels = c("SD/PD", "CR/PR"))
  
  dir.create("output/models/")
  if(identical(runName, c('Bulk','Mean DSP')) == TRUE){
    save(p, aucList, file = file.path("output/models/", "modelboth.rdata"))
    res <- scores_calculator(devList, x[,c(VarSelected)], y, family = "binomial")
    save(res, VarSelected, x, y, file = file.path("output/models/", "scores_modelboth.rdata"))
  } else if (runName == c('Mean DSP') ){
    save(p, aucList, file = file.path("output/models/", "modelDSP.rdata"))
    res <- scores_calculator(devList, x[,c(VarSelected)], y, family = "binomial")
    save(res, VarSelected, file = file.path("output/models/", "scores_modelDSP.rdata"))
  } else {
    save(p, aucList, file = file.path("output/models/", "modelRNA.rdata"))
    res <- scores_calculator(devList, x[,c(VarSelected)], y, family = "binomial")
    save(res, VarSelected, file = file.path("output/models/", "scores_modelRNA.rdata"))
  }
}

rm(list = c("p", "aucList", "runNames", "runName", "alphaLength", 
            "bsList", "dataFinal", "filename", "measure", "nalpharep", 
            "x", "y", "selectedx", "nfolds", "tmp", "addVarlist", "res",
            "standbylist", "VarSelected", "modelSize", "i", "devList", "alphaList"))


#### 3.6: create Figure 4 containing boxplots of scores and ROC curves for three models 
# load fitted model for Bulk DNA only
load(file = file.path("output/models", "modelRNA.rdata"))
p1 <- p
apply(do.call(rbind, aucList[[2]][,5]), 2, 
      function(x) quantile(x, c(0.5, 0.025, 0.975))) %>% round(3)

# load fitted model for DSP only
load(file = file.path("output/models", "modelDSP.rdata"))
p2 <- p
apply(do.call(rbind, aucList[[2]][,5]), 2, 
      function(x) quantile(x, c(0.5, 0.025, 0.975))) %>% round(3)

# load fitted model for DSP and Bulk DNA
load(file = file.path("output/models", "modelboth.rdata"))
p3 <- p
apply(do.call(rbind, aucList[[2]][,5]), 2, 
      function(x) quantile(x, c(0.5, 0.025, 0.975))) %>% round(3)

p_all <- p1[[1]] + ggtitle(expression(bold("Combined model"))) + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  p2[[1]] + ylab("") + ggtitle(expression(bold("DSP model"))) + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  p3[[1]] + ylab("") + ggtitle(expression(bold("Bulk RNA model"))) + 
  theme(plot.title = element_text(hjust = 0.5)) + 
  p1[[2]] + theme(plot.margin = margin(t = -20, unit = "pt")) + 
  p2[[2]] + ylab("") + theme(plot.margin = margin(t = -20, unit = "pt")) + 
  p3[[2]] + ylab("") + theme(plot.margin = margin(t = -20, unit = "pt")) + 
  plot_layout(nrow = 2) 

ggsave(p_all, filename = file.path("figs", "tiff", "Figure4.tiff"), 
       dpi = 400, width = 8, height = 5, units = "in",
       type = "cairo")
ggsave(p_all, filename = file.path("figs", "svg", "Figure4.svg"), 
       dpi = 400, width = 8, height = 5, units = "in")
ggsave(p_all, filename = file.path("figs", "jpg", "Figure4.jpg"), 
       dpi = 400, width = 8, height = 5, units = "in",
       type = "cairo")

rm(list = c("p", "p1", "p2", "p3", "p_all", "aucList"))

################################################################
#### Section 4: Selecting an efficient subset of predictors ####
#### 4.1: calculate AUC for numbers of predictor ranging from 4 to 13
load(file = file.path("output/models", "scores_modelboth.rdata"))
if (FALSE){ 
  # !!! this chunk of code takes very long time to run. Output were saved in /ouput folder.  
  dir.create("output/permutations")
  for(k in 4:13){
    if (k > 5){
      set.seed(seed)
      genes = replicate(2000000, sample(1:nrow(res[[1]]), k))
      genes = genes[, !duplicated(t(genes))]
    } else{
      genes = combn(1:nrow(res[[1]]), k)
    }
    rocobjsave <- rep(list(NA), min(100, ncol(genes)))
    for(j in 1:ncol(genes)){
      coefVar <- res[[1]][genes[,j],]
      
      scoresVar <- apply(x[, as.character(coefVar$gene), drop = F], 1, 
                         function(y) {sum(y * coefVar$coefficient)})
      
      rocobj <- roc(as.numeric(y==1), scoresVar, direction = "<")
      if(all(is.na(rocobjsave))==TRUE){
        rocobjsave[[1]] <- list(rocobj, coefVar$gene)
      } else if(any(is.na(rocobjsave))==TRUE) {
        rocobjsave[[which(is.na(rocobjsave))[1]]] <- list(rocobj, coefVar$gene)
      } else {
        aucvec <- sapply(rocobjsave, function(x) x[[1]]$auc)
        if(min(aucvec) < rocobj$auc){
          rocobjsave[[which.min(aucvec)]] <- list(rocobj, coefVar$gene)
        }
      }
    }
    save(rocobjsave, file = file.path("output/permutations", paste0(k,".rdata")))
  }
}

#### 4.2: select subsets of predictors with top 10 highest AUC
# load res for later use
load(file.path("output/models/", "scores_modelboth.rdata")) 
dir.create("output/top10subsets")

for (k in 4:13){
  load(file.path("output/permutations", paste0(k,".rdata")))
  aucvec <- sapply(rocobjsave, function(x) x[[1]]$auc)
  aucindex <- order(aucvec, decreasing =TRUE)[1:10]
  aucmat <- sapply(rocobjsave[aucindex], function(x) x[[2]])
  minvalue <- min(table(c(aucmat))[order(table(c(aucmat)), decreasing = TRUE)][1:k])

  if( length(which(table(c(aucmat))>=minvalue)) > k ){
    rocobjmat <- NULL
    genesListtmp <- names(table(c(aucmat))[which(table(c(aucmat)) > minvalue)])
    for(var in names(which(table(c(aucmat))==minvalue))){
      coefVar <- res[[1]][which(res[[1]]$gene %in% c(genesListtmp, var)),]
      
      scoresVar <- apply(x[, as.character(coefVar$gene), drop = F], 1, 
                         function(y) {sum(y * coefVar$coefficient)})
      rocobj <- roc(as.numeric(y==1), scoresVar, direction = "<")
      
      rocobjmat <- rbind(rocobjmat, data.frame(auc = rocobj$auc, var = var))
    }
    print(k)
    print(rocobjmat)
    genesList <- c(genesListtmp, as.character(rocobjmat$var[which.max(rocobjmat$auc)]))
    remove(genesListtmp)
  } else {
    genesList <- names(table(c(aucmat))[order(table(c(aucmat)), decreasing = TRUE)][1:k])
  }
    
  coefVar <- res[[1]][which(res[[1]]$gene %in% genesList),]
  
  scoresVar <- apply(x[, as.character(coefVar$gene), drop = F], 1, 
                     function(y) {sum(y * coefVar$coefficient)})
  
  rocobj <- roc(as.numeric(y==1), scoresVar, direction = "<")
  
  save(rocobj, genesList, 
       file = file.path("output/top10subsets", paste0(k,"gene.rdata")))
}

#### 4.3: generate heatmap of an efficient subset of predictors
gene_df <- lapply(4:13, function(k){
  load(file.path("output","top10subsets", paste0(k,"gene.rdata")))
  return(as.character(genesList))
})
auc <- sapply(4:13, function(k){
  load(file.path("output","top10subsets", paste0(k,"gene.rdata")))
  return(rocobj$auc)
})

# find the unique set of predictors 
genesall <- unique(sort(unlist(gene_df)))
df <- data.frame(matrix(".", nrow = length(genesall), ncol = 10),
                 row.names = genesall, stringsAsFactors = FALSE)

for (k in 4:13){
  load(file.path("output","permutations", paste0(k,".rdata")))
  aucvec <- sapply(rocobjsave, function(x) x[[1]]$auc)
  aucindex <- order(aucvec, decreasing =TRUE)[1:10]
  aucmat <- sapply(rocobjsave[aucindex], function(x) x[[2]])
  df[, k-3] <- sapply(genesall, function(gene) sum(apply(aucmat, 2, function(x) any(x == gene))))
}

colnames(df) <- paste0("K = ", 4:13)
rownames(df) <- gsub("Mean_", "DSP: ", genesall)
df <- df[c(rownames(df)[-grep("DSP:", rownames(df))], 
           rownames(df)[grep("DSP:", rownames(df))]), ]

# the top 8 most frequently selected predictors
gene8 <- c("CCNO", "ID4", "IER3", "Mean_MSH2_Melanocyte", 
           "MGMT", "NRDE2", "TNFAIP6", "IL2RB")

annot_row <- 
  data.frame(
    "Data" = c("Bulk RNA", "GeoMx DSP")[as.numeric(grepl("DSP", rownames(df)))+1])

annotation_colors = list(
  Data = c(`Bulk RNA`="#000080", `GeoMx DSP`="#F5C242"))

dspind <- grep("DSP:", rownames(df))
rownames(df)[dspind] <- c("MSH2 in S100/HMB45", 
                          "PhosphoSTAT3 in CD68",
                          "PhosphoSTAT5 in CD68")
row.names(annot_row) <- rownames(df)
test_labels <- df
test_labels[] <- ""

for (k in 4:13){
  load(file.path("output","top10subsets", paste0(k,"gene.rdata")))
  if("Mean_MSH2_Melanocyte" %in% genesList){
    genesList <- c( setdiff(genesList, "Mean_MSH2_Melanocyte"), "MSH2 in S100/HMB45")
  } 
  if ("Mean_PhosphoSTAT3_CD68" %in% genesList){
    genesList <- c( setdiff(genesList, "Mean_PhosphoSTAT3_CD68"), "PhosphoSTAT3 in CD68")
  } 
  if ("Mean_PhosphoSTAT5_CD68" %in% genesList){
    genesList <- c( setdiff(genesList, "Mean_PhosphoSTAT5_CD68"), "PhosphoSTAT5 in CD68")
  }
  test_labels[genesList, k-3] <- "âˆ—"
}

# output the heatmap as figure 5
p <- pheatmap::pheatmap(df*10,  cluster_cols = FALSE, 
                        cluster_rows = FALSE,
                        cellwidth = 20, 
                        cellheight = 15,
                        fontsize = 10,
                        display_numbers = test_labels,
                        fontsize_number = 15,
                        angle_col = "315", 
                        annotation_row = annot_row, 
                        annotation_colors = annotation_colors,
                        number_format = "%.2f %%")

ggsave(p, filename = file.path("figs", "tiff", "Figure5.tiff"), 
       dpi = 400, width = 8, height = 5, units = "in",
       type = "cairo")
ggsave(p, filename = file.path("figs", "svg", "Figure5.svg"), 
       dpi = 400, width = 8, height = 5, units = "in")
ggsave(p, filename = file.path("figs", "jpg", "Figure5.jpg"), 
       dpi = 400, width = 8, height = 5, units = "in",
       type = "cairo")

rm(list = c("annot_row", "annotation_colors", "aucmat", "coefVar", "df",
            "gene_df", "p", "rocobj", "rocobjsave", "test_labels", 
            "auc", "aucindex", "aucvec", "dspind", "gene8",
            "genesall", "genesList", "k", "scoresVar"))

#### 4.4: evaluate the performances of K predictors from 4 to 13
# extract results from saved rdata files
resmat <- c()
aucvalvec <- c()
for(k in 4:13){
  load(file.path("output","top10subsets", paste0(k,"gene.rdata")))
  print(length(genesList))
  dataFinal <- data.frame(y = as.factor(y), x[,as.character(genesList)])
  set.seed(seed)
  aucList <- kernelboot(dataFinal, function(x) 
    smooth_bootstrap_selected(x, testfit = res[[3]], genesList), 
    R=nrep, kernel = "gaussian")
  
  tmp <- data.frame(K = k, 
                    index = c("AUC", "PPV","NPV","Sensitivity","Specificity"),
                    rbind(auc = quantile(do.call(rbind, aucList[[2]][,1]), 
                                         c(0.025, 0.5, 0.975)),
                          apply(do.call(rbind, aucList[[2]][,5]), 2, 
                                function(x) quantile(x, c(0.025, 0.5, 0.975))) %>% t()),
                    row.names = NULL)
  resmat <- rbind(resmat, tmp)
  aucvalvec <- c(aucvalvec, aucList[[1]][[1]])
}

# output the connected scatter plots as figure 6 for five metrics
for (ind in c("AUC", "PPV","NPV","Sensitivity","Specificity")){
  p <- ggplot(subset(resmat, subset = (index == ind)), 
              aes(x = K, y = X50.)) +
    geom_point(size = 3, color = "darkblue") +
    geom_line() +
    geom_errorbar(aes(ymin = X2.5., ymax = X97.5.), width = 0.5) +
    ylab(ind) +
    xlab("Number of variables") +
    scale_y_continuous(limits = c(0, 1)) +
    scale_x_continuous(breaks = c(4:13)) +
    theme_bw() +
    theme(text = element_text(size = 15),
          legend.position = "none",
          panel.grid.minor = element_blank(),
          panel.grid.major = element_blank())
  
  if(ind == "PPV"){
    p <- p + ylab("Positive Predictive Value")
  }
  
  if(ind == "NPV"){
    p <- p + ylab("Negative Predictive Value")
  }
  
  ggsave(filename = file.path("figs", "tiff", 
                              paste0("Figure6", "-", ind, ".tiff")), 
         dpi = 400, width = 6, height = 5, units = "in",
         type = "cairo")
  ggsave(filename = file.path("figs", "svg", 
                              paste0("Figure6", "-", ind, ".svg")), 
         dpi = 400, width = 6, height = 5, units = "in")
  ggsave(filename = file.path("figs", "jpg", 
                         paste0("Figure6", "-", ind, ".jpg")), 
         dpi = 400, width = 6, height = 5, units = "in",
         type = "cairo")

}

rm(list = c("aucList", "dataFinal", "p", "resmat", "rocobj", "tmp",
            "aucvalvec", "genesList", "ind", "k"))


#### 4.5: calculate 95% CI of AUC for 8 predictors 
# generate the boxplot of scores and ROC curves, figure 7 
gene8 <- c("CCNO", "ID4", "IER3", "Mean_MSH2_Melanocyte", 
           "MGMT", "NRDE2", "TNFAIP6", "IL2RB")

dataFinal <- data.frame(y = as.factor(y), x[, gene8])
set.seed(seed)
aucList <- kernelboot(dataFinal, function(x) 
  smooth_bootstrap_selected(x, testfit = res[[3]], gene8), 
  R=nrep, kernel = "gaussian")

p <- ggboxroc(aucList = aucList, labels = c("SD/PD", "CR/PR"))

# save the results for later use
save(p, aucList, file = file.path("output", "models", "model8.rdata"))

# save the boxplot of scores and ROC curves as figure 7
p_comb <- p[[1]] + p[[2]]

ggsave(p_comb, filename = file.path("figs", "tiff", "Figure7.tiff"), 
       dpi = 400, width = 16/3, height = 3, units = "in",
       type = "cairo")
ggsave(p_comb, filename = file.path("figs", "svg", "Figure7.svg"), 
       dpi = 400, width = 16/3, height =3, units = "in")
ggsave(p_comb, filename = file.path("figs", "jpg", "Figure7.jpg"), 
       dpi = 400, width = 16/3, height = 3, units = "in",
       type = "cairo")

apply(do.call(rbind, aucList[[2]][,5]), 2, 
      function(x) quantile(x, c(0.5, 0.025, 0.975))) %>% round(3)

set.seed(seed)
ci.coords(aucList[[1]][[2]], x=0.95, input = "sensitivity", ret="specificity") 

rm(list = c("p_comb", "p", "aucList", "dataFinal",
            "varimp", "res", "VarSelected", "y"))

###############################################################
#### Section 5: evaluate 8 predictors on clinical benefit ####
#### 5.1: load data and define the clinical benefit outcome
load(file.path("output/models/", "scores_modelboth.rdata"))
gene8 <- c("CCNO", "ID4", "IER3", "Mean_MSH2_Melanocyte", 
           "MGMT", "NRDE2", "TNFAIP6", "IL2RB")


#### 5.2: prepare data for fitting the logistic regressions
dataFinal <- data.frame(y = factor(as.numeric(annot$Clinical.Benefit=="CB")), x[,gene8])

#### 5.3: calculate the 95% CI in AUC
set.seed(seed)
aucList <- kernelboot(dataFinal, function(x) 
  smooth_bootstrap_selected(x, testfit = res[[3]], gene8), 
  R=nrep, kernel = "gaussian")

#### 5.4: save the boxplot of scores and ROC curves as figure 8
p <- ggboxroc(aucList = aucList, labels = c("No", "Yes"))

p_comb <- p[[1]]+p[[2]]

ggsave(p_comb, filename = file.path("figs", "tiff", "Figure8.tiff"), 
       dpi = 400, width = 16/3, height =3, units = "in",
       type = "cairo")
ggsave(p_comb, filename = file.path("figs", "svg", "Figure8.svg"), 
       dpi = 400, width = 16/3, height =3, units = "in")
ggsave(p_comb, filename = file.path("figs", "jpg", "Figure8.jpg"), 
       dpi = 400, width = 16/3, height =3, units = "in",
       type = "cairo")

apply(do.call(rbind, aucList[[2]][,5]), 2, 
      function(x) quantile(x, c(0.5, 0.025, 0.975))) %>% round(3)

rm(list = c("p_comb", "p", "aucList"))

##################################################################
#### Section 6: evaluate 8 predictors on survival data, VITAL ####
#### 6.1: load data and define survival outcome
y <- Surv(time = annot$OS_FROM_START_OF_ITX, event = annot$VITAL)

# calculate the best cutoff
load(file.path("output", "models", "model8.rdata"))
cutoff <- coords(aucList[[1]][[2]], "best")[1]

#### 6.2: prepare data for survival analysis 
dat <- data.frame(y = y, 
                  scores = aucList[[1]][[4]])

#### 6.3: run the survival analysis 
# use cutoff to create two groups, low an high
dat$group <- factor(dat$scores > unname(unlist(cutoff)), labels = c("Low", "High"))
fit <- survfit(y ~ group, data = dat)
cox <- coxph(y ~ group, data = dat)
summary(cox)

#### 6.4: save the survival plot as figure 9
ggsurvplot(fit,
           palette = c("red", "darkblue"), 
           size = 1,  # change line size
           break.time.by = 250, # break time axis by 250
           conf.int = FALSE, # Add confidence interval
           pval = FALSE, # Add p-value
           legend.title = "Group", 
           legend.labs = c(paste0("Low (n = ", table(dat$group)['Low'], ")"),
                           paste0("High (n = ", table(dat$group)['High'], ")"))) + 
  xlab("Time (days)") + ylab("Overall Survival") -> p

p$plot +
  geom_label(label = expression("logrank "*italic(P)*" < 0.0001"), 
             x = 250, y = 0.1, label.size = NA)  
  

ggsave(filename = file.path("figs", "tiff", "Figure9.tiff"), 
       dpi = 400, width = 6, height = 5, units = "in",
       type = "cairo")
ggsave(filename = file.path("figs", "svg", "Figure9.svg"), 
       dpi = 400, width = 6, height = 5, units = "in")
ggsave(filename = file.path("figs", "jpg", "Figure9.jpg"), 
       dpi = 400, width = 6, height = 5, units = "in",
       type = "cairo")

rm(list = c("fit", "p", "aucList", "dat", "y"))


################################################################################
#### Section 7: evaluate 8 predictors on survival data, PROG_STATUS_BY_SCAN ####
#### 7.1: load new data for 2nd survival analysis
annot2 <- as.data.frame(read_excel('data/graphing_adjusted_log2_expression_data_WITH DSP.xlsx', 
                                   sheet = "Transposed Annotations"))
stopifnot(identical(annot$ID, annot2$ID...1))
annot$PFS_BY_SCAN  <- annot2$PFS_BY_SCAN
annot$PROG_STATUS_BY_SCAN  <- annot2$PROG_STATUS_BY_SCAN 

#### 7.2: prepare data for survival analysis 
load(file.path("output", "models", "model8.rdata"))
y <- Surv(time = annot$PFS_BY_SCAN, event = annot$PROG_STATUS_BY_SCAN)
dat <- data.frame(y = y, 
                  scores = aucList[[1]][[4]])

# use the same cutoff from above
dat$group <- factor(dat$scores > unname(unlist(cutoff)), labels = c("Low", "High"))

#### 7.3: run the survival analysis 
fit <- survfit(y ~ group, data = dat)
cox <- coxph(y ~ group, data = dat)
summary(cox)

#### 7.4: save the survival plot as figure 10
ggsurvplot(fit,
           palette = c("red", "darkblue"), 
           size = 1,  # change line size
           break.time.by = 250, # break time axis by 250
           conf.int = FALSE, # Add confidence interval
           pval = TRUE, # Add p-value
           pval.coord = c(50, 0.10), 
           legend.title = "Group", 
           legend.labs = c(paste0("Low (n = ", table(dat$group)['Low'], ")"),
                           paste0("High (n = ", table(dat$group)['High'], ")")))+ 
  xlab("Time (days)") + ylab("Progression-Free Survival") -> p

p$plot +
  geom_label(label = expression("logrank "*italic(P)*" < 0.0001"), 
             x = 250, y = 0.1, label.size = NA) 

ggsave(filename = file.path("figs", "tiff", "Figure10.tiff"), 
       dpi = 400, width = 6, height = 5, units = "in",
       type = "cairo")
ggsave(filename = file.path("figs", "svg", "Figure10.svg"), 
       dpi = 400, width = 6, height = 5, units = "in")
ggsave(filename = file.path("figs", "jpg", "Figure10.jpg"), 
       dpi = 400, width = 6, height = 5, units = "in",
       type = "cairo")

rm(list = c("fit", "p", "aucList", "dat", "y"))

